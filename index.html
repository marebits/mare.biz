<!DOCTYPE html>
<html lang="en" prefix="og: http://ogp.me/ns# fb: http://ogp.me/ns/fb#" 🦄 🐎🐱>
	<head>
		<meta charset="utf-8">
		<meta content="width=device-width, initial-scale=1" name="viewport">
		<!-- <base href="https://mare.biz/"> -->
		<link href="https://mare.biz/" rel="canonical" type="text/html">
		<link as="style" rel="preload" href="index.css" importance="high" type="text/css">
		<link as="font" crossorigin="anonymous" rel="preload" href="WoodrowW00-Reg.woff2" importance="high" type="font/woff2">
		<link rel="modulepreload" href="script/stars.mjs" importance="high" type="application/javascript">
		<link as="fetch" crossorigin="anonymous" rel="preload" href="constants.json" importance="high" type="application/json">
		<link rel="preconnect" href="https://fonts.googleapis.com">
		<link crossorigin rel="preconnect" href="https://fonts.gstatic.com">
		<link href="https://mare.biz/" rel="home index" type="text/html">
		<!-- <link href="/manifest.jsonmanifest" rel="manifest" type="application/manifest+json"> -->
		<!-- <link href="/sitemap.xml" rel="sitemap" type="text/xml"> -->
		<!-- <meta content="/browserconfig.xml" name="msapplication-config"> -->
		<meta content="Mare Bits — For those who love mares" name="title" property="og:title">
		<meta content="$MARE: An Ethereum token for all the oppressed bronies, horsefuckers, and nor/mlp/eople out there. These bits are bringing mares to the world of blockchain. It may be a meme token, but with your support we can show the furry tokens that hoofs always beat paws. /)" property="og:description">
		<meta content="mare, mare bits, ethereum, erc20, bitcoin, crypto, money, brony, pony, lauren faust, nft" name="keywords">
		<meta content="https://mare.biz/marebits/marebits.png" property="og:image">
		<meta content="350" property="og:image:width">
		<meta content="350" property="og:image:height">
		<meta content="image/png" property="og:image:type">
		<meta content="website" property="og:type">
		<meta content="https://mare.biz/" property="og:url">
		<meta content="summary" name="twitter:card">
		<meta content="@MareBits" name="twitter:site">
		<link href="//iwtcits.com" importance="high" rel="bestpony" type="text/html">
		<link href="//donutsteal.pl" rel="code-license content-license license" type="text/html">
		<script type="application/ld+json">
			{
				"@context": {
					"@base": "https://mare.biz/",
					"@version": 1.1,
					"@vocab": "https://schema.org"
				},
				"@graph": [
					{
						"@id": "",
						"@type": "WebPage",
						"audience": {
							"@type": "Audience",
							"audienceType": "horsefuckers",
							"alternateName": "pony fags",
							"description": "Anonymous nor/mlp/eople who frequent the /mlp/ board on 4chan.",
							"image": "https://cdn.twibooru.org/img/view/2020/7/20/1858730.png",
							"name": "horsefuckers"
						}, 
						"author": {
							"@type": "Person",
							"additionalName": "Corpulent Brony",
							"address": {
								"@type": "PostalAddress",
								"addressCountry": "US",
								"addressLocality": "Orlando",
								"addressRegion": "FL",
								"postOfficeBoxNumber": "621622",
								"postalCode": "32862-1622"
							},
							"email": "iwtcits@mare.biz",
							"gender": "horsefucker",
							"givenName": "Twifag",
							"honorificPrefix": "Mr.",
							"nationality": "US",
							"telephone": "+1 (844) 4TWI-FAG",
							"name": "Twifag",
							"url": "https://twitter.com/MareBits"
						},
						"description": "$MARE: An Ethereum token for all the oppressed bronies, horsefuckers, and nor/mlp/eople out there. These bits are bringing mares to the world of blockchain. It may be a meme token, but with your support we can show the furry tokens that hoofs always beat paws. /)",
						"encoding": {
							"@type": "MediaObject",
							"contentUrl": "https://mare.biz/",
							"encodingFormat": "html"
						},
						"encodingFormat": "text/html",
						"isAccessibleForFree": true,
						"keywords": "mare, mare bits, ethereum, erc20, bitcoin, crypto, money, brony, pony, lauren faust, nft",
						"license": "https://donutsteal.pl/",
						"mainContentOfPage": {
							"@type": "WebPageElement",
							"cssSelector": "main"
						},
						"material": "bits",
						"name": "Mare Bits — For those who love mares",
						"primaryImageOfPage": "https://mare.biz/marebits/marebits.png", 
						"timeRequired": "P15M",
						"typicalAgeRange": "18-",
						"url": "https://mare.biz/"
					}
				]
			}
		</script>
		<link href="favicon.svg" rel="shortcut icon" sizes="any" type="image/svg+xml">
		<link href="favicon.ico" rel="alternate icon shortcut" sizes="256x256 192x192 128x128 96x96 64x64 48x48 40x40 32x32 24x24 16x16" type="image/vnd.microsoft.icon">
		<title>Mare Bits — For those who love mares</title>
		<link href="index.css" rel="stylesheet">
		<script id="constants" src="constants.json" type="application/json"></script>
		<script async src="script/stars.mjs" type="module"></script>
	</head>
	<body data-is-js-disabled>
		<script>delete self.document.body.dataset.isJsDisabled;</script>
		<svg role="presentation">
			<defs>
				<filter id="darken-mare">
					<feComponentTransfer>
						<feFuncR type="linear" slope="0.25"></feFuncR>
						<feFuncG type="linear" slope="0.25"></feFuncG>
						<feFuncB type="linear" slope="1.25"></feFuncB>
					</feComponentTransfer>
					<feColorMatrix type="saturate" values="0.65"></feColorMatrix>
				</filter>
				<filter id="darken-moon">
					<feComponentTransfer result="darken">
						<feFuncR type="linear" slope="0.4"></feFuncR>
						<feFuncG type="linear" slope="0.4"></feFuncG>
						<feFuncB type="linear" slope="1.25"></feFuncB>
					</feComponentTransfer>
				</filter>
			</defs>
		</svg>
		<div class="stars" id="stars-front" role="presentation"></div>
		<div class="stars" id="stars-middle" role="presentation"></div>
		<div class="stars" id="stars-back" role="presentation"></div>
		<header>
			<div class="absolute-container" id="moon-background" role="presentation"></div>
			<picture class="absolute-container">
				<source sizes="(max-width: 635px) 40vw, 25vw" srcset="moon/144.avif 144w, moon/180.avif 180w, moon/254.avif 254w, moon/480.avif 480w, moon/720.avif 720w, moon/960.avif 960w, moon/full.avif 1800w" type="image/avif">
				<img id="moon" role="presentation" sizes="(max-width: 635px) 40vw, 25vw" src="moon/full.webp" srcset="moon/144.webp 144w, moon/180.webp 180w, moon/254.webp 254w, moon/480.webp 480w, moon/720.webp 720w, moon/960.webp 960w, moon/full.webp 1800w" type="image/webp">
			</picture>
			<picture class="absolute-container">
				<source srcset="marebits/marebits.svg" type="image/svg+xml">
				<source sizes="(max-width: 635px) 35vw, 22vw" srcset="marebits/126.avif 126w, marebits/159.avif 159w, marebits/223.avif 223w, marebits/423.avif 423w, marebits/634.avif 634w, marebits/845.avif 845w, marebits/marebits.webp 1920w" type="image/avif">
				<img id="marebits" role="presentation" sizes="(max-width: 635px) 35vw, 22vw" src="marebits/marebits.webp" srcset="marebits/126.webp 126w, marebits/159.webp 159w, marebits/223.webp 223w, marebits/423.webp 423w, marebits/634.webp 634w, marebits/845.webp 845w, marebits/marebits.webp 1920w" type="image/webp">
			</picture>
		</header>
		<main>
			<h1 class="big-header card header">
				<a href="//etherscan.io/token/0xc5a1973e1f736e2ad991573f3649f4f4a44c3028" rel="external noopener" target="_blank">$MARE</a>: An Ethereum token for the oppressed bronies, horsefuckers, and nor/mlp/eople.  These bits are bringing mares to the world of blockchain.  It may be a meme token, but with your support we can show the furry tokens that hoofs <em>always</em> beat paws.
				<dfn title="brohoof /)">/)</dfn>
			</h1>
			<h2 class="big-header detail"><dfn><abbr title="too long; didn't read">tl;dr</abbr></dfn></h2>
			<section class="card header">
				<dl id="briefing-details">
					<dt>Token Symbol</dt><dd>$MARE</dd>
					<dt>Max Supply</dt><dd><data value="233666428910.958452213243697852">233,666,428,911.958452213243697852</data></dd>
					<dt>Presale Starts</dt><dd><!-- <time datetime="2021-09-16T00:00:00Z"> -->Soon, I hope<!-- </time> --></dd>
					<dt>Contract Address</dt><dd>
						<contract-link button-color="white" contract="0xc5a1973e1f736e2ad991573f3649f4f4a44c3028" href-base="https://etherscan.io/token/">0xc5a1973e1f736e2ad991573f3649f4f4a44c3028</contract-link>
					</dd>
				</dl>
			</section>
			<h2 class="big-header detail">Details</h2>
			<section>
				<h3 class="card detail header">
					<picture>
						<source sizes="3.75rem" srcset="cutie_marks/TS-1x.avif 1x, cutie_marks/TS-3x.avif 2x, cutie_marks/TS-3x.avif 3x, cutie_marks/TS.avif" type="image/avif">
						<source sizes="3.75rem" srcset="cutie_marks/TS-1x.webp 1x, cutie_marks/TS-3x.webp 2x, cutie_marks/TS-3x.webp 3x" type="image/webp">
						<img class="cutie-mark" loading="lazy" role="presentation" src="cutie_marks/TS.png" type="image/png">
					</picture>
					Supply
				</h3>
				<div class="card detail twilight">
					Supply itself is limited to approximately <data value="233666428910.958452213243697852">233,666,428,911</data> tokens. No new tokens will ever be minted, and the contract itself does not support minting.  This means there is a <em>limited supply</em>, making these some <em>hot</em> Mare Bits.
				</div>
			</section>
			<section>
				<h3 class="card detail header">
					Liquidity
					<picture>
						<source sizes="3.75rem" srcset="cutie_marks/RD-1x.avif 1x, cutie_marks/RD-3x.avif 2x, cutie_marks/RD-3x.avif 3x, cutie_marks/RD.avif" type="image/avif">
						<img class="cutie-mark" loading="lazy" role="presentation" sizes="3.75rem" src="cutie_marks/RD.webp" srcset="cutie_marks/RD-1x.webp 1x, cutie_marks/RD-3x.webp 2x, cutie_marks/RD-3x.webp 3x" type="image/webp">
					</picture>
				</h3>
				<div class="card detail dash">
					These Mare Bits are also moister than an oyster!  Our goal is to squirt <data value="210299786019.8626069919193280668">90% of tokens</data> into presale and liquidity provider contracts with various exchanges; the resulting LP tokens will be locked for at least <time datetime="PT4Y">5 years</time>
				</div>
			</section>
			<section>
				<h3 class="card detail header">
					<picture>
						<source sizes="3.75rem" srcset="cutie_marks/FS-1x.avif 1x, cutie_marks/FS-3x.avif 2x, cutie_marks/FS-3x.avif 3x, cutie_marks/FS.avif" type="image/avif">
						<img class="cutie-mark" loading="lazy" role="presentation" sizes="3.75rem" src="cutie_marks/FS.webp" srcset="cutie_marks/FS-1x.webp 1x, cutie_marks/FS-3x.webp 2x, cutie_marks/FS-3x.webp 3x" type="image/webp">
					</picture>
					Developer Tokens
				</h3>
				<div class="card detail flutter">
					Only about <data value="23366642891.0958452213243697852">10% of tokens</data> will initially be held by the dev, and if we can find a suitable vesting platform they will only be released on a certain schedule, helping to guarantee the developer won't pull out early (no mare likes that, details TBD)
				</div>
			</section>
			<section>
				<h3 class="card detail header">
					Reducing Arbitrage Risks
					<picture>
						<source sizes="3.75rem" srcset="cutie_marks/RY-1x.avif 1x, cutie_marks/RY-3x.avif 2x, cutie_marks/RY-3x.avif 3x, cutie_marks/RY.avif" type="image/avif">
						<img class="cutie-mark" loading="lazy" role="presentation" sizes="3.75rem" src="cutie_marks/RY.webp" srcset="cutie_marks/RY-1x.webp 1x, cutie_marks/RY-3x.webp 2x, cutie_marks/RY-3x.webp 3x" type="image/webp">
					</picture>
				</h3>
				<div class="card detail rarity">
					In order to mitigate the risks of <q>impermanent</q> loss due to arbitrage, at least <data value="105149893009.9313034959596640334">50% of the tokens set aside for liquidity</data> will immediately be issued to a single exchange (likely <a href="//uniswap.org/" target="_blank">Uniswap</a>) with the remaining kept aside with periodic releases to allow for the addition of more liquidity providers (this is another situation where they will be locked away if a solution can be found, details TBD)
				</div>
			</section>
			<section>
				<h3 class="card detail header">
					<picture>
						<source sizes="3.75rem" srcset="cutie_marks/PP-1x.avif 1x, cutie_marks/PP-3x.avif 2x, cutie_marks/PP-3x.avif 3x, cutie_marks/PP.avif" type="image/avif">
						<img class="cutie-mark" loading="lazy" role="presentation" sizes="3.75rem" src="cutie_marks/PP.webp" srcset="cutie_marks/PP-1x.webp 1x, cutie_marks/PP-3x.webp 2x, cutie_marks/PP-3x.webp 3x" type="image/webp">
					</picture>
					Airdrops
				</h3>
				<div class="card detail pinkie">
					We may donate some of the <data value="23366642891.0958452213243697852">10% of dev tokens</data> held back for airdrops/giveaways in order to help promote Mare Bits.  We want everyone talking about these juicy bits, so we'll be trying <em>hard</em> to come up with some way to reward shills
				</div>
			</section>
			<section>
				<h3 class="card detail header">
					Blockchain Portability
					<picture>
						<source sizes="3.75rem" srcset="cutie_marks/AJ-1x.avif 1x, cutie_marks/AJ-3x.avif 2x, cutie_marks/AJ-3x.avif 3x, cutie_marks/AJ.avif" type="image/avif">
						<img class="cutie-mark" loading="lazy" role="presentation" sizes="3.75rem" src="cutie_marks/AJ.webp" srcset="cutie_marks/AJ-1x.webp 1x, cutie_marks/AJ-3x.webp 2x, cutie_marks/AJ-3x.webp 3x" type="image/webp">
					</picture>
				</h3>
				<div class="card detail apple">
					<a href="//polygon.technology/" rel="external noopener" target="_blank">Polygon</a> has provided a <a href="//wallet.matic.network/bridge" rel="external noopener" target="_blank">PoS bridge</a> between Mare Bits on Ethereum and the Matic blockchain; this means you can easily move your Mare Bits to and from Matic to take advantage of lower transaction fees.  We will be looking to provide liquidity on Matic as well.  <contract-link bex-name="Polygonscan" contract="0xb362A97aD06C907c4b575D3503fB9DC474498480" href-base="https://polygonscan.com/token/">See the contract on Polygonscan</contract-link>
				</div>
			</section>
			<h2 class="big-header detail">Join Us</h2>
			<section class="card nav">
				If you also believe in mares and want to make this project a success, please reach out and lend a hoof.
				<nav>
					<ul class="social">
						<li>
							<a href="//pone.social/@mare" rel="external me noopener" title="Mastodon" target="_blank"><img src="mastodon.svg" type="image/svg+xml"></a>
						</li>
						<li>
							<a href="//goto.mlp.chat/#/#mare-bits:mlp.chat" rel="external noopener" title="Matrix" target="_blank">
								<img src="matrix.svg" type="image/svg+xml">
							</a>
						</li>
						<li><a href="//t.me/marebits" rel="external noopener" title="Telegram" target="_blank"><img src="telegram.svg" type="image/svg+xml"></a></li>
						<li>
							<a href="//twitter.com/MareBits" rel="external me noopener" title="Twitter" target="_blank"><img src="twitter.svg" type="image/svg+xml"></a>
						</li>
						<li><a href="mailto:iwtcits@mare.biz" rel="external noopener" title="E-mail" target="_blank"><img src="email.svg" type="image/svg+xml"></a></li>
					</ul>
				</nav>
			</section>
			<h2 class="big-header detail">Pre-Sale</h2>
			<section class="card detail twilight">
				<div><span class="alert">In Testing</span>: The pre-sale is currently running on the Ropsten test network.  If you don't know what you're doing, don't do anything.</div>
				<div>Presale contract address: <contract-link contract="" href-base="https://ropsten.etherscan.io/address/"></contract-link>
				<div>
					Token contract address: <contract-link contract="0x35c94a5a563d7dc00b7edaa455e0a931691deb27" href-base="https://ropsten.etherscan.io/token/"></contract-link>
					<button class="action-button" disabled id="add-to-metamask">Add Token to MetaMask</button>
				</div>
				<hr>
				<div>
					<noscript>
						<strong>If you want to participate in the pre-sale, you <em>must</em> enable JavaScript!</strong>
						<hr>
					</noscript>
					<strong>If you'd like to participate in our (<span class="alert">TEST</span>) pre-sale, follow these easy-to-use instructions:</strong>
					<ol>
						<li>Click the button below to connect your <a href="//metamask.io/" rel="external noopener" target="_blank">MetaMask</a> wallet to this page.</li>
						<li>Enter the number of Mare Bits you want to buy</li>
						<li>Click buy, sign the transaction, and you're set!</li>
					</ol>
				</div>
				<hr>
				<div>
					<button class="action-button" disabled id="wallet-connect">Connect Wallet</button>
					<div>
						<output id="wallet-message">
							You must have a <a href="//metamask.io/" rel="external noopener" target="_blank">MetaMask</a> wallet to participate.
						</output>
					</div>
				</div>
				<hr>
				<div>
					<input autocomplete="off" autocorrect="off" id="purchase-amount" inputmode="number" max="3" min="0" placeholder="1 ETH = 65426600000 $MARE" step="0.0000000001" type="number" value="">
					<button class="action-button" disabled id="purchase">Purchase $MARE</button>
					<div>
						You will receive <output-data-message default="0" id="purchase-balance"></output-data-message> $MARE.
					</div>
				</div>
				<hr>
				<button class="action-button" disabled id="withdraw">Withdraw $MARE</button>
				<div>
					You currently have <output-data-message default="0" id="bits-balance"></output-data-message> $MARE pre-ordered.  Once the pre-sale is over, you will be able to withdraw them by using the button above.
				</div>
			</section>
		</main>
		<footer>
			<img id="ground" class="absolute-container" loading="lazy" role="presentation" src="ground.svg" type="image/svg+xml">
			<picture class="absolute-container">
				<source sizes="50vw" srcset="mare_covered_in_bits/180.avif 180w, mare_covered_in_bits/318.avif 318w, mare_covered_in_bits/360.avif 360w, mare_covered_in_bits/960.avif 960w, mare_covered_in_bits/1440.avif 1440w, mare_covered_in_bits/1920.avif 1920w, mare_covered_in_bits/full.avif 2405w" type="image/avif">
				<img id="mare-covered-in-bits" loading="lazy" role="presentation" sizes="50vw" src="mare_covered_in_bits/full.webp" srcset="mare_covered_in_bits/180.webp 180w, mare_covered_in_bits/318.webp 318w, mare_covered_in_bits/360.webp 360w, mare_covered_in_bits/960.webp 960w, mare_covered_in_bits/1440.webp 1440w, mare_covered_in_bits/1920.webp 1920w, mare_covered_in_bits/full.webp 2405w" type="image/webp">
			</picture>
		</footer>
		<script>
			"use strict";

			(async function() {
				const CONSTANTS = await (await self.fetch(self.document.getElementById("constants").src, { Accept: "application/json" })).json();

				class BetterMap extends self.Map {
					constructor(iterable) {
						super(iterable);
						return new self.Proxy(this, {
							get: function(target, property) {
								const result = self.Reflect.get(target, property);

								if (typeof result === "function")
									return result.bind(target);
								else if (target.hasOwnProperty(property))
									return target[property];
								else if (target.has(property))
									return target.get(property);
								return result;
							}
						});
					}
				}
				class EventSet extends self.Set {
					constructor(addMethodName, removeMethodName, iterable) {
						super(iterable);
						this.addMethodName = addMethodName;
						this.isListening = false;
						this.removeMethodName = removeMethodName
					}
					add(event) {
						super.add(event);

						if (this.isListening)
							event.target[this.addMethodName](event.event, event.listener, event.options);
						return event;
					}
					addMany(events) {
						for (const event of events)
							this.add(event);
						return events;
					}
					startListening() {
						if (this.isListening)
							return;
						super.forEach((event) => event.target[this.addMethodName](event.event, event.listener, event.options));
						this.isListening = true;
					}
					delete(event) {
						if (this.isListening)
							event.target[this.removeMethodName](event.event, event.listener, event.options);
						super.delete(event);
					}
					stopListening() {
						if (!this.isListening)
							return;
						super.forEach((event) => event.target[this.removeMethodName](event.event, event.listener, event.options));
						this.isListening = false;
					}
				}
				const events = new EventSet("addEventListener", "removeEventListener");
				class MareEvent {
					constructor(target, event, listener, options) {
						this.target = target;
						this.event = event;
						this.listener = listener;
						this.options = options;
					}
				}
				class ContractLink extends self.HTMLElement {
					static ATTRIBUTES = new self.Map(CONSTANTS.CONTRACT_LINK.ATTRIBUTES);
					static ANCHOR_TITLE_TAG(bexName) { return `View contract on ${bexName}`; }
					static BUTTON_IMAGE_TAG(buttonColor) { return `data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 16 16'><g fill='none' stroke='${self.encodeURIComponent(buttonColor)}' stroke-linejoin='round'><path d='M2 5h9v9H2z'/><path d='M5 5V2h9v9h-3'/></g></svg>`; }
					static __promiseTimeout(delay) { return new self.Promise(function(resolve) { self.setTimeout(resolve, delay); }); }

					constructor(options) {
						super();
						this.__initializeOptions(options);
						const doc = self.document.createDocumentFragment();
						const style = self.document.createElement("style");
						style.textContent = `
							:host {
								--button-height: 1rem;
								--button-width: var(--button-height);
								align-items: center;
								display: flex;
							}
							* {
								box-sizing: border-box;
								margin: 0;
							}
							a {
								display: inline-block;
								max-width: 90%;
								overflow: hidden;
								text-decoration: underline;
								text-decoration-style: dotted;
								text-overflow: ellipsis;
							}
							a:link { color: var(--link-color); }
							a:visited { color: var(--link-visited-color); }
							a:focus, a:hover { background-color: var(--link-focus-background-color); }
							a:active {
								background-color: var(--link-active-background-color);
								color: var(--link-active-color);
							}
							:host-context(.card.twilight) a { --link-visited-color: var(--twilight-red); }
							button { display: none; }
							button > output { opacity: 0; }
							@media screen {
								button {
									background-color: transparent;
									border: none;
									cursor: pointer;
									display: unset;
									flex-shrink: 0;
									height: var(--button-height);
									overflow: visible !important;
									padding: 0;
									position: relative;
									width: var(--button-width);
								}
								button::after {
									background-image: url("${this.constructor.BUTTON_IMAGE_TAG(this.buttonColor)}");
									background-repeat: no-repeat;
									content: "";
									display: inline-block;
									height: 100%;
									width: 100%;
								}
								button.white-stroke::after { filter: brightness(0) invert(1); }
								button > output {
									--width: calc(var(--card-header-font-size) * 2.75);
									background-color: var(--twilight-orange);
									border-radius: 0.5rem;
									font-size: calc(var(--card-header-font-size) / 1.5);
									font-weight: 700;
									height: var(--card-header-font-size);
									left: calc(var(--width) * -1);
									padding: 0.25rem;
									position: absolute;
									transition-duration: 1s;
									transition-property: opacity;
									width: var(--width);
									z-index: 100;
								}
							}
						`;
						doc.appendChild(style);
						this.anchor = self.document.createElement("a");
						this.anchor.textContent = (super.textContent.length === 0) ? this.contract : super.textContent;
						this.anchor.href = this.href;
						this.anchor.rel = CONSTANTS.CONTRACT_LINK.REL;
						this.anchor.title = this.title;
						this.anchor.target = CONSTANTS.CONTRACT_LINK.TARGET;
						doc.appendChild(this.anchor);
						this.button = self.document.createElement("button");
						events.add(new MareEvent(this.button, "click", () => this.__onCopyContractClick().catch(console.error), { passive: true }));
						this.button.title = CONSTANTS.CONTRACT_LINK.BUTTON_TITLE;
						doc.appendChild(this.button);
						super.attachShadow({ mode: "open" }).appendChild(doc);
					}
					get bexName() { return this.__getAttributeOrDefault("bex-name", CONSTANTS.CONTRACT_LINK.DEFAULT_BEX_NAME); }
					get buttonColor() { return this.__getAttributeOrDefault("button-color", CONSTANTS.CONTRACT_LINK.DEFAULT_BUTTON_COLOR); }
					get contract() { return super.getAttribute("contract"); }
					get hrefBase() { return super.getAttribute("href-base"); }
					get href() { return new self.URL(this.contract, this.hrefBase); }
					get title() { return this.constructor.ANCHOR_TITLE_TAG(this.bexName); }
					get __copiedOutputElement() {
						if (typeof this.___copiedOutputElement === "undefined") {
							this.___copiedOutputElement = self.document.createElement("output");
							this.___copiedOutputElement.appendChild(self.document.createTextNode(CONSTANTS.CONTRACT_LINK.COPY_MESSAGE));
							this.button.appendChild(this.___copiedOutputElement);
						}
						return this.___copiedOutputElement;
					}
					__getAttributeOrDefault(attribute, alternative) {
						const value = super.getAttribute(attribute);

						if (value == null || value.length === 0)
							return alternative;
						return value;
					}
					__hideCopiedOutput() { this.__copiedOutputElement.style.opacity = 0; }
					__initializeOptions(options) {
						if (typeof options !== "object" || self.Object.keys(options).length === 0)
							return;
						this.constructor.ATTRIBUTES.forEach((attributeName, optionName) => {
							if (typeof options[optionName] === "string")
								super.setAttribute(attributeName, options[optionName]);
						});

						if (typeof options.textContent === "string")
								super.replaceChildren(self.document.createTextNode(options.textContent));
					}
					__promiseTimeout(func, delay) { return new self.Promise((resolve) => self.setTimeout(() => resolve(func.call(this)), delay)); }
					__showCopiedOutput() { this.__copiedOutputElement.style.opacity = 1; }
					async __onCopyContractClick(event) {
						await this.__writeTextToClipboard(this.contract);
						this.__hideCopiedOutput();
						await this.__promiseTimeout(this.__showCopiedOutput, 100);
						await this.__promiseTimeout(this.__hideCopiedOutput, 4000);
					}
					__writeTextToClipboard(text) { // returns self.Promise
						if ("navigator" in self && "clipboard" in self.navigator && "writeText" in self.navigator.clipboard)
							return self.navigator.clipboard.writeText(self.String(text));
						else
							return this.__promiseTimeout(function() {
								const textArea = self.document.createElement("textarea");
								textArea.value = self.String(text);
								self.document.body.appendChild(textArea);
								textArea.select();
								self.document.execCommand("copy");
								textArea.remove();
								resolve();
							});
					}
				}
				class OutputDataMessage extends self.HTMLElement {
					constructor() {
						super();
						const doc = self.document.createDocumentFragment();
						this.outputElement = self.document.createElement("output");
						this.dataElement = self.document.createElement("data");
						this.outputElement.appendChild(this.dataElement);
						doc.appendChild(this.outputElement);
						this.value = this.default;
						super.attachShadow({ mode: "open" }).appendChild(doc);
					}
					get default() { return super.getAttribute("default"); }
					get value() { return super.getAttribute("value"); }
					set value(value) {
						value = value.toString();

						if (value.length === 0)
							value = this.default;
						super.setAttribute("value", this.dataElement.value = this.dataElement.textContent = value);
						return true;
					}
				}
				class __Web3Mare {
					constructor(web3) { this.web3 = web3; }
					get balance() { return this.web3.currentAccount.then(this.__balanceOf.bind(this)); }
					get bestPony() {}
					get capReached() {}
					get closingTime() {}
					get hasClosed() { return Promise.resolve(false); }
					get isFinalized() { return Promise.resolve(false); }
					get isOpen() { return Promise.resolve(true); }
					get openingTime() {}
					get weiRaised() {}
					buyTokens(amount) {}
					watchAsset() {
						return this.web3.__ethRequest({
							method: "wallet_watchAsset", 
							params: {
								options: {
									address: CONSTANTS.TOKEN_CONTRACT_ADDRESS, 
									decimals: 18, 
									"symbol": CONSTANTS.TOKEN_SYMBOL, 
									image: CONSTANTS.TOKEN_ICON_PNG
								},
								type: "ERC20"
							}
						});
					}
					withdrawTokens() {}
					__balanceOf(account) { return Promise.resolve(130853200000n); }
				}
				class Web3 extends self.EventTarget {
					static events = new self.Map([
						["connected", new self.Event("connected")], 
						["disconnected", new self.Event("disconnected")], 
						["initialized", new self.Event("initialized")]
					]);

					constructor() {
						super();
						this.__eth = this.__initializeEth().then((eth) => this.__addEvents(eth)).catch(console.error);
						this.mare = new __Web3Mare(this);
					}
					get accounts() { return this.__ethRequestMethod("eth_accounts"); }
					get chainId() { return this.__chainId; }
					get currentAccount() { return this.accounts.then(accounts => accounts[0]); }
					get eth() { return this.__eth; }
					get isConnected() { return this.eth.then(eth => eth.isConnected()); }
					get isProviderConnected() { return this.currentAccount.then(currentAccount => typeof currentAccount !== "undefined"); }
					async connect() { this.__onAccountsChanged(await this.__ethRequestMethod("eth_requestAccounts")); }
					__addEvents(eth) {
						this.__events = new EventSet("addListener", "removeListener", [
							new MareEvent(eth, "accountsChanged", this.__onAccountsChanged.bind(this)), 
							new MareEvent(eth, "chainChanged", this.__onChainChanged.bind(this)), 
							new MareEvent(eth, "connect", this.__onConnected.bind(this)), 
							new MareEvent(eth, "disconnect", this.__onDisconnected.bind(this))
						]);
						this.__events.startListening();
						events.add(new MareEvent(self.document, "visibilitychange", this.__onSelfVisibilityChange.bind(this), { passive: true }));
						return eth;
					}
					async __ethRequest(args) {
						const eth = await this.eth;
						return eth.request(args);
					}
					__ethRequestMethod(method) { return this.__ethRequest({ method }); }
					__initializeEth() {
						const eventTarget = this;
						let handled = false;
						return new Promise(function(resolve, reject) {
							const event = new MareEvent(self, "ethereum#initialized", handleEthereum, { once: true, passive: true });
							let timeout;

							function handleEthereum() {
								if (handled)
									return;
								handled = true;
								events.delete(event);
								self.clearTimeout(timeout);
								const { ethereum } = self;

								if (ethereum) {
									eventTarget.dispatchEvent(eventTarget.constructor.events.get("initialized"));
									resolve(ethereum);
								}
								reject("Cannot detect an installed web3 compatible wallet.");
							}

							if (self.ethereum)
								handleEthereum();
							else {
								events.add(event);
								timeout = self.setTimeout(handleEthereum, 3000);
							}
						});
					}
					__onAccountsChanged(accounts) {
						console.log("accounts changed");
						if (accounts.length === 0)
							this.dispatchEvent(this.constructor.events.get("disconnected"));
						else
							this.dispatchEvent(new self.CustomEvent("accountsChanged", { detail: { accounts } }));
					}
					__onConnected(connectInfo) {
						console.log("connected");
						this.__chainId = connectInfo.chainId;
						// this.accounts.then(this.__onAccountsChanged.bind(this)).catch(console.error);
						this.dispatchEvent(this.constructor.events.get("connected"));
					}
					__onChainChanged(chainId) { self.location.reload(); }
					__onDisconnected(error) {
						console.error(error);
						this.dispatchEvent(this.constructor.events.get("disconnected"));
						// need to reload page to reconnect
					}
					__onSelfVisibilityChange() {
						if (self.document.visibilityState === "hidden")
							this.__events.stopListening();
						else
							this.__events.startListening();
					}
				}
				self.Object.defineProperty(Web3.prototype, "utils", { enumerable: true, value: 
					class Web3Utils {
						static __ETH_UNITS = new BetterMap(CONSTANTS.ETH_UNITS);
						static get ETH_UNITS() { return this.__ETH_UNITS; }
						static fromWei(number, unit = this.ETH_UNITS.ether) {
							if (!this.ETH_UNITS.has(unit))
								unit = this.ETH_UNITS.ether;
							const decimals = unit.length - 1;
							number = number.toString();
							return (number.substring(0, number.length - decimals) + "." + number.slice(-decimals)).replace(/\.?0+$/, "");
						}
						static toWei(number, unit = this.ETH_UNITS.ether) {
							if (!this.ETH_UNITS.has(unit))
								unit = this.ETH_UNITS.ether;
							const inputValueSplit = number.toString().split(".");

							if (inputValueSplit.length === 1)
								inputValueSplit[1] = "0";
							return BigInt((inputValueSplit[0] + inputValueSplit[1].padEnd(unit.length - 1, "0")).replace(/^0*/, ""));
						}
					}
				});

				const TOKEN_SALE_RATE = BigInt(CONSTANTS.TOKEN_SALE_RATE);
				const TARGET_CHAIN_ID = self.Number.parseInt(CONSTANTS.TARGET_CHAIN_ID, 16);
				const addToMetaMaskButton = self.document.getElementById("add-to-metamask");
				const bitsBalanceOutput = self.document.getElementById("bits-balance");
				const purchaseAmountInput = self.document.getElementById("purchase-amount");
				const purchaseBalanceOutput = self.document.getElementById("purchase-balance");
				const purchaseButton = self.document.getElementById("purchase");
				const walletConnectButton = self.document.getElementById("wallet-connect");
				const walletMessageOutput = self.document.getElementById("wallet-message");
				const withdrawButton = self.document.getElementById("withdraw");
				const web3 = new Web3();
				events.addMany([
					new MareEvent(addToMetaMaskButton, "click", onAddToMetaMaskClick, { passive: true }), 
					new MareEvent(purchaseAmountInput, "input", onPurchaseAmountInput, { passive: true }), 
					new MareEvent(purchaseButton, "click", onPurchaseButtonClick, { passive: true }), 
					new MareEvent(self.document, "visibilitychange", onVisibilityChange, { passive: true }), 
					new MareEvent(walletConnectButton, "click", onWalletConnectClick, { passive: true }), 
					new MareEvent(web3, "accountsChanged", () => updateButtons().catch(console.error)), 
					new MareEvent(web3, "connected", () => updateButtons().catch(console.error)), 
					new MareEvent(web3, "disconnected", () => updateButtons().catch(console.error)), 
					new MareEvent(web3, "initialized", onWeb3Initialized), 
					new MareEvent(withdrawButton, "click", onWithdrawClick, { passive: true })
				]);
				
				// async function getCid() {
				// 	if (self.location.host === "mare.biz") {
				// 		const headers = new self.Headers({ Accept: "application/dns-json" });
				// 		const url = new self.URL("https://cloudflare-dns.com/dns-query");
				// 		url.search = new self.URLSearchParams({ name: "_dnslink.mare.biz", type: "TXT", do: false, cd: false });
				// 		const request = new self.Request(url, { headers });
				// 		const response = await self.fetch(request);
				// 		const responseJson = await response.json();
				// 		const dnsLink = responseJson.Answer.find(function(answer) { return answer.type === 16; }).data.split("/");
				// 		return dnsLink[dnsLink.length - 1].slice(0, -1);
				// 	} else {
				// 		const currentPathname = self.location.pathname;

				// 		if (currentPathname.slice(0, 6) === "/ipfs/")
				// 			return currentPathname.substring(6);
				// 	}
				// 	return "Cannot determine CID";
				// }
				function onAddToMetaMaskClick(event) { web3.mare.watchAsset().catch(console.error); }
				function onPurchaseAmountInput(event) {
					if (!event.target.checkValidity()) {
						purchaseBalanceOutput.value = "0";
						console.error("Invalid purchase amount entered.");
						return;
					}
					const newPurchaseAmount = web3.utils.toWei(event.target.value) * TOKEN_SALE_RATE;
					purchaseBalanceOutput.value = web3.utils.fromWei(newPurchaseAmount);
				}
				function onPurchaseButtonClick(event) {

				}
				function onVisibilityChange() {
					if (self.document.visibilityState === "hidden")
						events.stopListening();
					else
						events.startListening();
				}
				function onWalletConnectClick() { web3.connect().catch(console.error); }
				function onWeb3Initialized() {}
				function onWithdrawClick() {}
				async function updateButtons() {
					const currentAccount = await web3.currentAccount;
					addToMetaMaskButton.disabled = true;
					purchaseButton.disabled = true;
					walletConnectButton.disabled = true;
					withdrawButton.disabled = true;
					updateWalletMessage("Click Connect Wallet above to proceed.");

					if (await web3.isConnected) {
						if (web3.chainId === CONSTANTS.TARGET_CHAIN_ID) {
							if (typeof currentAccount === "undefined")
								walletConnectButton.disabled = false;
							else {
								if (await web3.mare.isOpen)
									purchaseButton.disabled = false;
								else if (await web3.mare.isFinalized)
									withdrawButton.disabled = false;
								updateWalletMessage("Connected to wallet:", new ContractLink({
									contract: currentAccount, hrefBase: "https://ropsten.etherscan.io/token/", textContent: currentAccount
								}));
								bitsBalanceOutput.value = await web3.mare.balance;
							}
							addToMetaMaskButton.disabled = false;
						} else
							updateWalletMessage(`Please change the network in your MetaMask wallet to ${CONSTANTS.CHAINS[TARGET_CHAIN_ID]}`);
					}
				}
				function updateWalletMessage(...nodesOrStrings) {
					if (nodesOrStrings.length === 1 && typeof nodesOrStrings[0] === "string")
						walletMessageOutput.textContent = nodesOrStrings[0];
					else
						walletMessageOutput.replaceChildren(...nodesOrStrings);
				}

				self.customElements.define("contract-link", ContractLink);
				self.customElements.define("output-data-message", OutputDataMessage);
				events.startListening();
				// getCid().then(console.log).catch(console.error);
			})().catch(console.error);
		</script>
	</body>
</html>